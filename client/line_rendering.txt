Rendering textured lines with thickness.

Implementations
* SDFs
* Triangulate the line into quads and triangles.

Problems

Shape of the corners.
I wanted the shape to be smooth so I decided to when drawing the line from a to b to c create an circular arc of radius half the width of the line around b from angle of the line ab + 90deg to bc + 90deg(choosing the smaller arc between those two).
Unity creates an arc of radius equal to the width of the line around the intersection point of the thickned lines (line ab translated along the normal by half width both up and down). I implemented this in one of the commits, but there are several issues with it. Because when the angle is small the intersection point moves down the line won't contain the actual points. Also to join the lines when there is no intersection point you have to choose some other point.

If a line is not straight there are multiple ways to represent a point.
Solution: Make the texture position x constant along the joining arc.

Joining the lines when there is no intersection point.
What all the implementations I have seen do is to fully render both quads the issue is that this causes self intersections.

Self intersections also called overdraw or local self intersection in the problem of offsetting.
Self intersections are only an issue if the line is transparent.
Because the algorithm when generating only looks at 3 neighbouring vertices at a time self intersections will happen. Normal self intersections are wanted (the acutall not thickened line crosses another part of the line), but the buggy ones look bad.
Removing all self intersections.
Self intersections are causes by 2 triangles overlapping so this issue can be resolved by using order independent transparency. First render only to the depth buffer and the render the image with depthFunc = GL_EQUAL. This also removes the wanted self intersections, but you could try to handle it by rendering the self intersecting parts in different passes. It might be hard to actually find the wanted intersections. 
What should be the depth in OIT.
* Index of the generated vertex. Still causes some atrifacts on sharp turns
* (texturePosition.y - 0.5) * 2.0. This could probably be made too look good. Haven't figured it out yet. One side looks good the other looks bad and wanted self intersections break "Different method of removing self intersections" commit. It would probably be nice if I could write a custom depth writing function, which might be possible using depth textures.

PathOffsetting.
Something like http://www.angusj.com/clipper2/Docs/Units/Clipper/Functions/InflatePaths.htm might work, but this implementation might not work because it says Caution: Offsetting self-intersecting polygons may produce unexpected results.
Tested it clipper2 completly breaks on self intersecting polygons.
It might be hard to find a good offsetting algorithm, because most of them remove self intersections because they use clipping for example 

Inkscape just renders the full quads each time doesn't do any clipping. The texture is constant along the arc.

Boolean operations on polygons break remove the wanted self intersections.

// Not anything too helpful https://stackoverflow.com/questions/687173/how-do-i-render-thick-2d-lines-as-polygons

There are two types of self-intersections discussed in the literature, these are local and
global. Local self-intersections occur when the curvature of a surface is less than the offset
distance
// https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=6292&context=etd

float lineSegmentSdf(vec2 p, vec2 start, vec2 end) {
    vec2 t = normalize(end - start);
    vec2 n = vec2(-t.y, t.x);
    float ld = dot(n, start);
    float d = dot(p, n) - ld;
    float dAlong = dot(p, t);
    float dAlongStart = dot(start, t);
    float dAlongEnd = dot(end, t);
    float along = clamp(dAlong, dAlongStart, dAlongEnd);
    vec2 cloestPointOnLine = along * t + ld * n;
    return distance(p, cloestPointOnLine);
}


float distanceAlong(vec2 p, vec2 start, vec2 end) {
    vec2 t = normalize(end - start);
    vec2 n = vec2(-t.y, t.x);
    float ld = dot(n, start);
    float d = dot(p, n) - ld;
    float dAlong = dot(p, t);
    float dAlongStart = dot(start, t);
    return dAlong - dAlongStart;
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = fragCoord;
    p /= iResolution.xy;
    p -= vec2(0.5);
    p.x *= iResolution.x / iResolution.y;
    //float d = distance(vec2(0.0), p);
    float len = 0.35;
    float angle = 1.0 + iTime / 5.0;
    vec2 v0 = vec2(cos(angle), sin(angle)) * len;
    vec2 v1 = vec2(0.0);
    vec2 v2 = vec2(len, 0.0);
    float d0 = lineSegmentSdf(p, v0, v1);
    float d1 = lineSegmentSdf(p, v1, v2);
    float d;
    float x;
    if (d0 < d1) {
        d = d0;
        x = distanceAlong(p, v0, v1);
    } else {
        d = d1;
        x = distance(v1, v2) + distanceAlong(p, v1, v2);
    }
    d = min(d0, d1);
    d -= 0.1;
    d = smoothstep(0.0, 0.5, d);
    
    if (d <= 0.0) {
        fragColor = vec4(hsv2rgb(vec3(x * 5.0, 1.0, 1.0)), 1.0);
        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);
    } else {
        fragColor = vec4(1.0);
    }
    
    //fragColor = vec4(vec3(d), 1.0);
}




















#define HASHSCALE 0.1031

float hash(float p)
{
	vec3 p3  = fract(vec3(p) * HASHSCALE);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }

float grad(float hash, float p)
{
    int i = int(1e4*hash);
	return (i & 1) == 0 ? p : -p;
}

float perlin(float p)
{
	float pi = floor(p), pf = p - pi, w = fade(pf);
    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;
}

float perlin01(float p)
{
	return (perlin(p) + 1.0) * 0.5;
}

#define M_PI 3.14159265358979323846

float rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}
float rand (vec2 co, float l) {return rand(vec2(rand(co), l));}
float rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}

float perlin(vec2 p, float dim, float time) {
	vec2 pos = floor(p * dim);
	vec2 posx = pos + vec2(1.0, 0.0);
	vec2 posy = pos + vec2(0.0, 1.0);
	vec2 posxy = pos + vec2(1.0);
	
	float c = rand(pos, dim, time);
	float cx = rand(posx, dim, time);
	float cy = rand(posy, dim, time);
	float cxy = rand(posxy, dim, time);
	
	vec2 d = fract(p * dim);
	d = -0.5 * cos(d * M_PI) + 0.5;
	
	float ccx = mix(c, cx, d.x);
	float cycxy = mix(cy, cxy, d.x);
	float center = mix(ccx, cycxy, d.y);
	
	return center * 2.0 - 1.0;
}

// p must be normalized!
float perlin(vec2 p, float dim) {
	
	vec2 pos = floor(p * dim);
	vec2 posx = pos + vec2(1.0, 0.0);
	vec2 posy = pos + vec2(0.0, 1.0);
	vec2 posxy = pos + vec2(1.0);
		
	float c = rand(pos, dim);
	float cx = rand(posx, dim);
	float cy = rand(posy, dim);
	float cxy = rand(posxy, dim);
	
	vec2 d = fract(p * dim);
	d = -0.5 * cos(d * M_PI) + 0.5;
	
	float ccx = mix(c, cx, d.x);
	float cycxy = mix(cy, cxy, d.x);
	float center = mix(ccx, cycxy, d.y);
	
	return center * 2.0 - 1.0;
	return perlin(p, dim, 0.0);
}

vec2 hash(vec2 p)
{
	p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float perlin(vec2 p)
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

	vec2  i = floor( p + (p.x+p.y)*K1 );
    vec2  a = p - i + (i.x+i.y)*K2;
    float m = step(a.y,a.x); 
    vec2  o = vec2(m,1.0-m);
    vec2  b = a - o + K2;
	vec2  c = a - 1.0 + 2.0*K2;
    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    return dot( n, vec3(70.0) );
}

float perlin01(vec2 p)
{
	return (perlin(p) + 1.0) * 0.5;
}

float octave01(vec2 p, int octaves) {
	int OCTAVES = 4;
    float amplitude = .5;
    float frequency = 0.;
	float value = 0.0;
    for (int i = 0; i < OCTAVES; i++) {
        value += amplitude * perlin01(p);
        p *= 2.;
        amplitude *= .5;
    }
	return value;
}

float lineSegmentSdf(vec2 p, vec2 start, vec2 end) {
    vec2 t = normalize(end - start);
    vec2 n = vec2(-t.y, t.x);
    float ld = dot(n, start);
    float d = dot(p, n) - ld;
    float dAlong = dot(p, t);
    float dAlongStart = dot(start, t);
    float dAlongEnd = dot(end, t);
    float along = clamp(dAlong, dAlongStart, dAlongEnd);
    vec2 cloestPointOnLine = along * t + ld * n;
    return distance(p, cloestPointOnLine);
}


float distanceAlong(vec2 p, vec2 start, vec2 end) {
    vec2 t = normalize(end - start);
    vec2 n = vec2(-t.y, t.x);
    float ld = dot(n, start);
    float d = dot(p, n) - ld;
    float dAlong = dot(p, t);
    float dAlongStart = dot(start, t);
    return dAlong - dAlongStart;
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = fragCoord;
    p /= iResolution.xy;
    p -= vec2(0.5);
    p.x *= iResolution.x / iResolution.y;
    //float d = distance(vec2(0.0), p);
    float len = 0.3;
    vec2 v0 = vec2(0.0f, len);
    vec2 v1 = vec2(0.0, -len);
    float d = lineSegmentSdf(p, v0, v1);
    d += 0.05;
    d = smoothstep(0.0, 0.5, d);
    //d *= 2.0;
    p.x += iTime / 2.0;
    //d /= octave01(p * 3.0, 4);
    d /= octave01(p * 3.0, 4);
    fragColor = vec4(vec3(d), 1.0);
}





















#define HASHSCALE 0.1031

float hash(float p)
{
	vec3 p3  = fract(vec3(p) * HASHSCALE);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }

float grad(float hash, float p)
{
    int i = int(1e4*hash);
	return (i & 1) == 0 ? p : -p;
}

float perlin(float p)
{
	float pi = floor(p), pf = p - pi, w = fade(pf);
    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;
}

float perlin01(float p)
{
	return (perlin(p) + 1.0) * 0.5;
}

#define M_PI 3.14159265358979323846

float rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}
float rand (vec2 co, float l) {return rand(vec2(rand(co), l));}
float rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}

float perlin(vec2 p, float dim, float time) {
	vec2 pos = floor(p * dim);
	vec2 posx = pos + vec2(1.0, 0.0);
	vec2 posy = pos + vec2(0.0, 1.0);
	vec2 posxy = pos + vec2(1.0);
	
	float c = rand(pos, dim, time);
	float cx = rand(posx, dim, time);
	float cy = rand(posy, dim, time);
	float cxy = rand(posxy, dim, time);
	
	vec2 d = fract(p * dim);
	d = -0.5 * cos(d * M_PI) + 0.5;
	
	float ccx = mix(c, cx, d.x);
	float cycxy = mix(cy, cxy, d.x);
	float center = mix(ccx, cycxy, d.y);
	
	return center * 2.0 - 1.0;
}

// p must be normalized!
float perlin(vec2 p, float dim) {
	
	vec2 pos = floor(p * dim);
	vec2 posx = pos + vec2(1.0, 0.0);
	vec2 posy = pos + vec2(0.0, 1.0);
	vec2 posxy = pos + vec2(1.0);
		
	float c = rand(pos, dim);
	float cx = rand(posx, dim);
	float cy = rand(posy, dim);
	float cxy = rand(posxy, dim);
	
	vec2 d = fract(p * dim);
	d = -0.5 * cos(d * M_PI) + 0.5;
	
	float ccx = mix(c, cx, d.x);
	float cycxy = mix(cy, cxy, d.x);
	float center = mix(ccx, cycxy, d.y);
	
	return center * 2.0 - 1.0;
	return perlin(p, dim, 0.0);
}

vec2 hash(vec2 p)
{
	p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float perlin(vec2 p)
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

	vec2  i = floor( p + (p.x+p.y)*K1 );
    vec2  a = p - i + (i.x+i.y)*K2;
    float m = step(a.y,a.x); 
    vec2  o = vec2(m,1.0-m);
    vec2  b = a - o + K2;
	vec2  c = a - 1.0 + 2.0*K2;
    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    return dot( n, vec3(70.0) );
}

float perlin01(vec2 p)
{
	return (perlin(p) + 1.0) * 0.5;
}

float octave01(vec2 p, int octaves) {
	int OCTAVES = 4;
    float amplitude = .5;
    float frequency = 0.;
	float value = 0.0;
    for (int i = 0; i < OCTAVES; i++) {
        value += amplitude * perlin01(p);
        p *= 2.;
        amplitude *= .5;
    }
	return value;
}

float lineSegmentSdf(vec2 p, vec2 start, vec2 end) {
    vec2 t = normalize(end - start);
    vec2 n = vec2(-t.y, t.x);
    float ld = dot(n, start);
    float d = dot(p, n) - ld;
    float dAlong = dot(p, t);
    float dAlongStart = dot(start, t);
    float dAlongEnd = dot(end, t);
    float along = clamp(dAlong, dAlongStart, dAlongEnd);
    vec2 cloestPointOnLine = along * t + ld * n;
    return distance(p, cloestPointOnLine);
}


float distanceAlong(vec2 p, vec2 start, vec2 end) {
    vec2 t = normalize(end - start);
    vec2 n = vec2(-t.y, t.x);
    float ld = dot(n, start);
    float d = dot(p, n) - ld;
    float dAlong = dot(p, t);
    float dAlongStart = dot(start, t);
    return dAlong - dAlongStart;
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = fragCoord;
    p /= iResolution.xy;
    p -= vec2(0.5);
    p.x *= iResolution.x / iResolution.y;
    //float d = distance(vec2(0.0), p);
    float len = 0.3;
    vec2 v0 = vec2(0.0f, len);
    vec2 v1 = vec2(0.0, -len);
    float d = lineSegmentSdf(p, v0, v1);
    d -= + p.y / 4.0;
    d += 0.01;
    d = smoothstep(0.0, 0.5, d);
    //d *= 2.0;
    //p.x += iTime / 2.0;
    //d /= octave01(p * 3.0, 4);
    //d /= octave01(p * 3.0, 4);
    p.y += iTime;
    d /= octave01(p * 3.0, 4);
    p.x += iTime;
    d += octave01(p * 2.0, 1);
    d = 1.0 - d;
    fragColor = vec4(vec3(d), 1.0);
}